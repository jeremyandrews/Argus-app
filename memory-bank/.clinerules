# Argus iOS App - Project Intelligence

This file captures important patterns, preferences, and project intelligence that helps Cline work more effectively with the Argus iOS app project. It will be updated as new patterns and insights are discovered.

## Code Style Preferences

### Swift Conventions
- Use Swift's native error handling with `do-catch` blocks
- Prefer Swift's strong typing and avoid force unwrapping when possible
- Use Swift's property wrappers (@Published, @State, etc.) for SwiftUI state management
- Follow Apple's Swift API Design Guidelines for naming conventions

### SwiftUI Patterns
- Use the MVVM pattern with ObservableObject for complex views
- Extract reusable components into separate views
- Use preview providers for all UI components
- Avoid excessive view modifiers that can impact performance
- Use updated onChange API (iOS 17+) with two parameters:
  ```swift
  // Deprecated in iOS 17 (single parameter version):
  .onChange(of: someValue) { newValue in
      // Handle change
  }
  
  // New API (two parameter version):
  .onChange(of: someValue) { oldValue, newValue in
      // Handle change with access to both values
  }
  ```

## Project-Specific Patterns

### File Organization
- Swift files are organized by functionality within the main Argus directory
- UI components are separated from data processing logic
- Utilities and helpers are in dedicated files (MarkdownUtilities, NotificationUtils, etc.)

### Data Flow
- The SyncManager handles all data synchronization with the backend
- The DatabaseCoordinator centralizes all database operations using the actor model
- View models observe data changes and update the UI accordingly
- ArticleModelAdapter handles bidirectional conversion between ArticleModel and NotificationData
- All fields in ArticleModel, including JSON fields (engineStats, similarArticles), must be transferred in both directions
- Both "from" conversion method and "updateBlobs" method need complete field mapping for proper app functionality

### View-ViewModel Integration
- ViewModels and Views may define their own enum types with the same names - always check for type compatibility
- When calling ViewModel methods that take enum parameters, always ensure proper type conversion:
  ```swift
  // Convert View's NavigationDirection enum to ViewModel's NavigationDirection enum
  let viewModelDirection: NewsDetailViewModel.NavigationDirection = 
      direction == .next ? .next : .previous
      
  // Then call the ViewModel method with the converted enum
  viewModel.navigateToArticle(direction: viewModelDirection)
  ```
- Use ViewModel properties directly for UI state management (button enabled/disabled states):
  ```swift
  // Previous button - disabled when at first article
  .disabled(viewModel.currentIndex == 0)
  .foregroundColor(viewModel.currentIndex > 0 ? .primary : .gray)
  ```
- Ensure UI state stays synchronized with ViewModel after operations:
  ```swift
  // After navigation, update UI state with ViewModel state
  currentIndex = viewModel.currentIndex
  clearCache() // Reset any view-specific cached content
  ```

### Known Implementation Paths
- Push notifications are set up using the Apple Push Notification Service and the AuthKey_KKR79MB4FW.p8 file
- Markdown conversion happens in MarkdownUtilities.swift
- Background sync operations are managed in BackgroundContextManager.swift
- Array chunking utilities are in ArrayExtensions.swift

## Swift 6 Concurrency Patterns

### NSAttributedString and Sendable Constraints
- NSAttributedString is not Sendable and requires special handling in async contexts
- Always use @MainActor for functions that generate or manipulate NSAttributedString for UI
- For LazyLoadingContentView and similar components, use Task { @MainActor in ... } to constrain the entire task
- Avoid passing NSAttributedString across actor boundaries without proper isolation:
  ```swift
  // Wrong: Crossing actor boundaries with non-Sendable type
  let attributedString = await backgroundActor.getAttributedString()
  
  // Correct: Keep operations isolated to MainActor
  await MainActor.run {
      let attributedString = getAttributedString()
      // Use attributedString here, within MainActor context
  }
  ```
- Generate rich text synchronously during database operations:
  ```swift
  // Wrong: Asynchronous fire-and-forget approach causes race conditions
  Task { @MainActor in
      _ = getAttributedString(for: .title, from: article)
  }
  
  // Correct: Synchronous generation ensures rich text exists before transaction completes
  await MainActor.run {
      _ = getAttributedString(for: .title, from: article)
      _ = getAttributedString(for: .body, from: article)
  }
  ```

### Actor Model Implementation
- The DatabaseCoordinator is implemented as a Swift actor to provide thread-safe access to SwiftData
- All database operations should go through the DatabaseCoordinator to ensure isolation
- Use the pattern: `await DatabaseCoordinator.shared.methodName()` for all database operations

### Variable Capture in Closures
- Create local copies of captured variables before using them in closures:
  ```swift
  let localCopy = capturedVariable
  // Use localCopy in closure instead of directly using capturedVariable
  ```
- When dealing with collections within actors, prefer collecting results in local collections first, then update actor-isolated state in a single step

### Transaction Patterns
- Use the performTransaction pattern for all database operations:
  ```swift
  try await performTransaction { coordinator, context in
      // Use context for database operations
      // Return result that will be returned from performTransaction
  }
  ```
- Add fallback paths for transaction errors, e.g.:
  ```swift
  return (try? await performTransaction { ... }) ?? defaultValue
  ```

### Batch Processing
- When processing batches of items, use ArrayExtensions.chunked(into:) to create smaller batches:
  ```swift
  for batch in items.chunked(into: 100) {
      // Process batch
  }
  ```
- Use Swift's TaskGroup for concurrent processing while controlling maximum concurrency

### NSCache Usage
- NSCache is not Sendable - avoid directly accessing actor-isolated NSCache properties from closures
- Instead, read values from caches at the beginning of functions, then use locals in closures
- Update caches after transaction completion, not within transaction blocks

### Actor Initialization and Self Capture
- Never capture self in a task or closure before all properties are initialized
- Use a two-step initialization pattern for actors with async dependencies:
  ```swift
  // Initialize properties to nil/default values first
  private var asyncDependency: AsyncDependency?
  
  init() {
    // Set all required properties
    self.asyncDependency = nil
    
    // After full initialization, create the task
    createInitializationTaskIfNeeded()
  }
  
  private func createInitializationTaskIfNeeded() {
    if asyncDependency != nil { return }
    
    // Use weak self to avoid retain cycles
    weak var weakSelf = self
    
    Task {
      let dependency = await AsyncDependency.shared
      
      // Update stored reference on the main actor
      if let strongSelf = weakSelf {
        await MainActor.run {
          strongSelf.asyncDependency = dependency
        }
      }
    }
  }
  ```
- For accessor methods that need the async dependency, implement wait-with-timeout pattern:
  ```swift
  private func getInitializedDependency() async throws -> AsyncDependency {
    // Try direct access first
    if let dependency = asyncDependency {
      return dependency
    }
    
    // Create the initialization task if needed
    createInitializationTaskIfNeeded()
    
    // Wait with timeout
    return try await withTimeout(duration: .seconds(5)) {
      try await initializationTask!.value
    }
  }
  ```

### SwiftData Context Safety Patterns
- Always implement a fallback mechanism when using direct DatabaseCoordinator methods
- For topic switching, use a two-tier approach:
  ```swift
  // First tier: Immediate UI update from cache
  if isCacheValid && notificationsCache.keys.contains(topicToUse) {
      let cachedTopicData = notificationsCache[topicToUse] ?? []
      let filtered = filterNotificationsWithCurrentSettings(cachedTopicData)
      
      // Update UI immediately with cached data
      Task(priority: .userInitiated) {
          let updatedGrouping = await createGroupedNotifications(filtered)
          
          await MainActor.run {
              self.filteredNotifications = filtered
              self.sortedAndGroupedNotifications = updatedGrouping
          }
      }
  }
  
  // Second tier: Fall back to traditional filtering if DatabaseCoordinator methods fail
  updateFilteredNotifications(force: true)
  ```
- Avoid context.save() inside complex asynchronous operations that might cause EXC_BAD_ACCESS
- When DatabaseCoordinator methods fail with context issues, catch the error and use established filtering methods

### SwiftData and Main Actor Patterns
- Always add @MainActor annotation to methods that access SwiftData contexts:
  ```swift
  // WRONG: Missing @MainActor annotation
  func countUnviewedArticles() async throws -> Int {
      let context = container.mainContext // This will fail in Swift 6
      let count = try context.fetchCount(descriptor)
      return count
  }
  
  // CORRECT: With @MainActor annotation
  @MainActor
  func countUnviewedArticles() async throws -> Int {
      let context = container.mainContext // This is now safe
      let count = try context.fetchCount(descriptor)
      return count
  }
  ```
- Never use await when accessing main actor-isolated properties from @MainActor-annotated code:
  ```swift
  // WRONG: Using await in @MainActor-annotated method
  @MainActor
  func getContext() async -> ModelContext {
      let context = await container.mainContext // This will fail in Swift 6
      return context
  }
  
  // CORRECT: Direct access in @MainActor-annotated method
  @MainActor
  func getContext() -> ModelContext {
      let context = container.mainContext // This is correct
      return context
  }
  ```
- Ensure proper error handling in all database operations:
  ```swift
  @MainActor
  func countUnviewedArticles() async throws -> Int {
      do {
          let context = container.mainContext
          let descriptor = FetchDescriptor<ArticleModel>(
              predicate: #Predicate<ArticleModel> { !$0.isViewed }
          )
          
          let count = try context.fetchCount(descriptor)
          ModernizationLogger.log(.debug, component: .articleService, 
              message: "Fetched unviewed article count: \(count)")
          return count
      } catch {
          ModernizationLogger.log(.error, component: .articleService, 
              message: "Error fetching unviewed articles: \(error)")
          throw ArticleServiceError.databaseError(error)
      }
  }
  ```
- Query the correct database model when models have been migrated:
  ```swift
  // WRONG: Querying legacy model after migration
  let descriptor = FetchDescriptor<NotificationData>(
      predicate: #Predicate<NotificationData> { !$0.isViewed }
  )
  
  // CORRECT: Querying current model
  let descriptor = FetchDescriptor<ArticleModel>(
      predicate: #Predicate<ArticleModel> { !$0.isViewed }
  )
  ```
- Always check permissions before attempting operations that require them:
  ```swift
  // For notification permissions
  @MainActor
  private static func hasNotificationPermission() async -> Bool {
      let settings = await UNUserNotificationCenter.current().notificationSettings()
      return settings.authorizationStatus == .authorized
  }
  
  @MainActor
  private static func performBadgeUpdate() async {
      // Check permission first
      guard await hasNotificationPermission() else {
          AppLogger.ui.warning("Cannot update badge: notification permission not granted")
          return
      }
      
      // Proceed with badge update
  }
  ```

## Modernization Strategy

### Three-Tier Architecture Pattern
- Implement a three-tiered architecture to maximize code reuse:
  1. **Data Layer**: ArticleService handles API and SwiftData operations
  2. **Business Logic Layer**: ArticleOperations contains shared operations
  3. **View Models Layer**: ViewModels specific to each view

- ArticleServiceProtocol enables dependency injection and testing:
  ```swift
  protocol ArticleServiceProtocol {
      func fetchArticles(topic: String?, isRead: Bool?, isBookmarked: Bool?, isArchived: Bool?) async throws -> [NotificationData]
      func fetchArticle(byId id: UUID) async throws -> NotificationData?
      func markArticle(id: UUID, asRead: Bool) async throws
      func markArticle(id: UUID, asBookmarked: Bool) async throws
      func markArticle(id: UUID, asArchived: Bool) async throws
      func deleteArticle(id: UUID) async throws
      // Other methods...
  }
  ```

- ArticleOperations provides shared functionality:
  ```swift
  class ArticleOperations {
      private let articleService: ArticleServiceProtocol
      
      init(articleService: ArticleServiceProtocol = ArticleService.shared) {
          self.articleService = articleService
      }
      
      // Shared operations for both NewsViewModel and NewsDetailViewModel
      func toggleReadStatus(for article: NotificationData) async throws {
          try await articleService.markArticle(id: article.id, asRead: !article.isViewed)
          NotificationUtils.updateAppBadgeCount()
      }
      
      func toggleBookmark(for article: NotificationData) async throws {
          try await articleService.markArticle(id: article.id, asBookmarked: !article.isBookmarked)
      }
      
      func getAttributedContent(for article: NotificationData, field: RichTextField) async -> NSAttributedString? {
          await MainActor.run {
              return getAttributedString(for: field, from: article, createIfMissing: true)
          }
      }
  }
  ```

### MVVM Pattern Implementation
- ViewModels should use the shared ArticleOperations for common functionality:
  ```swift
  class NewsViewModel: ObservableObject {
    private let articleOperations: ArticleOperations
    
    @Published var articles: [Article] = []
    @Published var isLoading: Bool = false
    @Published var error: Error? = nil
    
    init(articleOperations: ArticleOperations = ArticleOperations()) {
        self.articleOperations = articleOperations
    }
    
    func refreshArticles() async {
        await MainActor.run { isLoading = true }
        do {
            let articles = try await articleOperations.fetchArticles(topic: selectedTopic)
            await MainActor.run { 
                self.articles = articles
                self.isLoading = false
            }
        } catch {
            await MainActor.run {
                self.error = error
                self.isLoading = false
            }
        }
    }
    
    func toggleReadStatus(for article: Article) async {
        try? await articleOperations.toggleReadStatus(for: article)
    }
  }
  ```
- ViewModels should be injected into views using @StateObject for view-owned ViewModels or @ObservedObject for parent-provided ViewModels:
  ```swift
  struct NewsView: View {
      @StateObject private var viewModel = NewsViewModel()
      
      var body: some View {
          List(viewModel.articles) { article in
              ArticleRow(article: article)
          }
          .refreshable {
              await viewModel.refreshArticles()
          }
      }
  }
  ```
- Business logic should be moved from views to ViewModels
- UI state should be represented by @Published properties in ViewModels
- Use a dependency injection approach for services accessed by ViewModels

### SwiftData and CloudKit Integration
- Avoid creating multiple ModelContainer instances with different schemas:
  ```swift
  // INCORRECT: Creating multiple containers with different schemas
  static let legacyContainer = ModelContainer(for: [LegacyModel.self])
  static let newContainer = ModelContainer(for: [NewModel.self])
  
  // CORRECT: One unified container with all models
  static let sharedContainer = ModelContainer(for: Schema([
      // Legacy models
      LegacyModel.self,
      // New models
      NewModel.self
  ]))
  ```
- Use a singleton container pattern to ensure consistent database access:
  ```swift
  class SwiftDataContainer {
      static let shared = SwiftDataContainer()
      let container: ModelContainer
      
      private init() {
          // Initialize container with all models in a single schema
      }
  }
  
  // In your app struct:
  @MainActor
  static var sharedModelContainer: ModelContainer {
      return SwiftDataContainer.shared.container
  }
  ```
- Implement proper fallback mechanisms for CloudKit errors:
  ```swift
  do {
      // First try CloudKit integration
      let cloudKitConfig = ModelConfiguration(schema: schema)
      container = try ModelContainer(for: schema, configurations: [cloudKitConfig])
  } catch {
      // Log CloudKit error details
      logger.error("CloudKit container creation failed: \(error)")
      
      // Fall back to local persistent storage
      do {
          let localConfig = ModelConfiguration(url: localDbPath)
          container = try ModelContainer(for: schema, configurations: [localConfig])
      } catch {
          // Last resort - in-memory container
          logger.critical("All persistent storage attempts failed: \(error)")
          let fallbackConfig = ModelConfiguration(isStoredInMemoryOnly: true)
          container = try ModelContainer(for: schema, configurations: [fallbackConfig])
      }
  }
  ```
- Ensure database table creation works for all required tables, adding direct SQL for legacy tables:
  ```swift
  // Direct SQL creation for legacy tables as fallback
  if tableCount == 0 || legacyTablesCount == 0 {
      let createTableSQL = """
      CREATE TABLE IF NOT EXISTS ZLEGACYTABLE (
          Z_PK INTEGER PRIMARY KEY AUTOINCREMENT,
          ZFIELD TEXT NOT NULL
      );
      """
      sqlite3_exec(db, createTableSQL, nil, nil, nil)
  }
  ```
- Use consistent URL paths for database access across all components
- Add table existence verification before operations:
  ```swift
  func verifyDatabaseTablesExist() -> Bool {
      // Check if required tables exist using SQLite directly
      let tableCheckQuery = """
          SELECT count(*) FROM sqlite_master
          WHERE type='table' AND (name LIKE '%REQUIREDTABLE');
      """
      // Execute query and verify result
  }
  ```
- Document CloudKit container identifiers in your code for clarity:
  ```swift
  // CloudKit container identifier from app entitlements
  private let cloudKitContainerIdentifier = "iCloud.com.company.AppName"
  ```

### SwiftData Implementation
- Use the @Model macro for all persistent model types:
  ```swift
  @Model
  class Article {
      // CloudKit compatibility: default values for all required properties
      var id: String = ""
      var title: String = ""
      var body: String = ""
      var publishDate: Date = Date()
      @Relationship(.cascade) var topics: [Topic]? = []
      
      // Additional fields for tracking state
      var isRead: Bool = false
      var isBookmarked: Bool = false
  }
  ```
- Ensure all required properties have default values for CloudKit compatibility
- Do not use @Attribute(.unique) constraints (not supported by CloudKit)
- Implement application-level uniqueness validation in repository layer
- Define the model container at the app level:
  ```swift
  @main
  struct ArgusApp: App {
      let container = ModelContainer(for: [Article.self, Topic.self])
      
      var body: some Scene {
          WindowGroup {
              ContentView()
          }
          .modelContainer(container)
      }
  }
  ```
- Use @Query for simple data access in views:
  ```swift
  @Query(filter: #Predicate<Article> { article in
      !article.isRead
  }, sort: \Article.publishDate, order: .reverse)
  private var unreadArticles: [Article]
  ```
- Create specialized SwiftData queries in ViewModels for more complex scenarios
- Implement proper error handling and retry mechanisms for data persistence operations

### Async/Await Implementation 
- Refactor API calls to use async/await instead of completion handlers:
  ```swift
  // Old approach with completion handlers
  func fetchArticles(completion: @escaping (Result<[Article], Error>) -> Void) {
      // Implementation
  }
  
  // New approach with async/await
  func fetchArticles() async throws -> [Article] {
      // Implementation
  }
  ```
- Use structured concurrency with proper task management:
  ```swift
  Task {
      try await articleService.updateArticlesFromServer()
  }
  ```
- Handle task cancellation properly:
  ```swift
  let task = Task {
      try await articleService.updateArticlesFromServer()
  }
  
  // Later if needed
  task.cancel()
  
  // In the operation
  try Task.checkCancellation()
  ```
- Use TaskGroup for concurrent operations with controlled concurrency
- Ensure proper actor isolation is maintained throughout the codebase

### Background Task Implementation
- Implement background tasks using .backgroundTask or BGTaskScheduler:
  ```swift
  // Modern implementation for iOS 18+
  .backgroundTask(.appRefresh("com.andrews.Argus.sync")) {
      await articleService.updateArticlesFromServer()
  }
  ```
- Handle task expiration properly:
  ```swift
  // For BGTaskScheduler (iOS 17 and earlier)
  task.expirationHandler = {
      // Handle task expiration (cancel any ongoing work)
  }
  ```
- Ensure background tasks are properly scheduled and managed
- Implement proper push notification handling with async/await

## Known Challenges
- UI becomes jittery during sync operations - will be addressed with MVVM refactoring
- Duplicate content issues occur during synchronization - will be resolved by SwiftData's unique constraints
- Swift 6 concurrency warnings for non-Sendable types like NSAttributedString in async contexts - will be eliminated with proper async/await implementation
- SwiftData context access issues can cause EXC_BAD_ACCESS crashes - will be addressed by using SwiftData's native context management instead of custom DatabaseCoordinator

## Argus API Server Endpoints and Behavior

### API Endpoints
- **Base URL**: `https://api.arguspulse.com`
- **Authentication**: `/authenticate` (POST)
  - Requires device token in request body: `{"device_id": "token"}`
  - Device token must be 64-character hex string
  - Returns JWT token valid for 1 hour: `{"token": "jwt_token_value"}`
- **Status Check**: `/status` (POST)
  - Can be called with or without JWT authentication
  - Returns simple "OK" response
- **Topic Management**:
  - `/subscriptions` (POST) - Get device's topic subscriptions
  - `/subscribe` (POST) - Subscribe device to a topic
    - Requires valid topic name and optional priority
    - Returns 409 CONFLICT if already subscribed
  - `/unsubscribe` (POST) - Unsubscribe device from a topic
    - Returns 404 NOT_FOUND if subscription doesn't exist
- **Articles Sync**: `/articles/sync` (POST)
  - Takes list of seen article URLs: `{"seen_articles": ["url1", "url2", ...]}`
  - Returns list of unseen article URLs: `{"unseen_articles": ["url1", "url2", ...]}`
  - This is the only endpoint for article management in the backend

### Important Implementation Notes
- **JWT Authentication**:
  - All endpoints except `/status` require Bearer token authentication
  - Tokens expire after 1 hour and must be refreshed
- **Topic Validation**:
  - Server has a predefined list of valid topics from environment variables
  - Default topics include "Alert: Direct", "Alert: Near", and "Test"
- **Client-Side Assumptions**:
  - Client code assumes additional endpoints that don't exist in server:
    - `/articles/{id}` for fetching a specific article (not implemented on server)
    - Direct article content fetching (not provided by server)
  - Client must handle these discrepancies with appropriate error handling
- **Missing Server Features**:
  - No direct endpoint to fetch article content by ID or URL
  - Client must implement workarounds for these limitations

### Resilience Patterns
- **Timeout Handling**: Client uses increased timeouts (15s connection, 60s resource)
- **Network Monitoring**: Client uses NWPathMonitor to track connectivity status
- **Exponential Backoff**: Client implements retries with increasing delays
- **Graceful Degradation**: Client returns empty arrays for 404 responses

## Modernization Component Mapping
- **SyncManager → BackgroundTaskManager + ArticleService** (✅ Completed):
  - ArticleService handles all data synchronization operations using async/await
  - BackgroundTaskManager handles all background task scheduling and execution
  - MigrationAdapter provides backward compatibility for legacy code during transition
  - CommonUtilities contains shared utility functions extracted from SyncManager

- **DatabaseCoordinator → SwiftData ModelContext**:
  - Direct use of SwiftData ModelContext will replace DatabaseCoordinator
  - Transaction management will be handled by SwiftData's built-in mechanisms
  - Complex queries will be handled by SwiftData's query DSL

- **Shared UI Logic → ArticleOperations**:
  - Common operations between NewsView and NewsDetailView extracted to shared layer
  - State management (read/bookmark/archive) handled consistently
  - Rich text processing consolidated in shared component
  - Consistent error handling across both views

- **NotificationCenter → Observable Properties**:
  - State updates will be communicated via @Published properties
  - Views will observe ViewModels through ObservableObject conformance
  - No more manual subscription/unsubscription management

- **Background Tasks → .backgroundTask or BGTaskScheduler**:
  - Modern background task APIs will replace custom background task handling
  - Proper task cancellation will be implemented for all background operations

## Modernization Strategy Guidelines
- Implement shared components first to establish foundation for ViewModels
- Prioritize code reuse to eliminate duplication between similar views
- Implement features incrementally, following the phased approach
- Maintain feature parity throughout the modernization process
- Test each component thoroughly before moving to the next phase
- Focus on fixing existing issues during the modernization process
- Keep comprehensive documentation of architectural decisions
- Use Swift's newest features where appropriate, but maintain compatibility with iOS 18
- Prioritize user experience over implementation elegance

## Shared Component Best Practices
- **Interface-Based Design**: Use protocols to define service interfaces
- **Dependency Injection**: Make dependencies injectable for testing
- **Clear Responsibilities**: Each layer should have well-defined responsibilities
- **Thin View Models**: Keep view models focused on UI state, delegate business logic to ArticleOperations
- **Consistent Error Handling**: Implement unified error types across components
- **State Synchronization**: Ensure shared state is consistent between components
- **Testing Strategy**: Test shared components independently from ViewModels

## User Workflow Preferences
- Focus on fixing critical bugs before adding new features
- Prioritize performance improvements in the sync process
- Document important decisions and their rationale
- Ensure smooth user experience during the transition to the new architecture

## Testing Approach
- UI tests are located in ArgusUITests directory
- Use TestHelpers.swift for common test utilities
- Critical user flows should have dedicated UI tests
- Add stress tests for DatabaseCoordinator to verify concurrency safety
